// fqparser.bison.y

/*
MIT License

Copyright (c) 2024 Zartaj Majeed

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

// c++ parser skeleton file
%skeleton "lalr1.cc"

// minimum bison version 3.8
%require "3.8"

%language "c++"

// generate parser description report .output file
%verbose

// names of generated parser files
%defines "fqparser.bison.h"
%output "fqparser.bison.cpp"

// enable debug trace
%define parse.trace

// add location parameter to symbol constructor
%locations

// generate header for location to be used outside of bison parser
%define api.location.file "locations.bison.h"

%define parse.error detailed

// want to return character token from flex but don't think it can work with api.token.constructor
// better lookup performance at cost of disallowing literal characters in grammar
%define api.token.raw

%code requires {
// %code requires codeblock goes at top of .h outside of namespace and parser class
// standard c++ #includes and defines

#include <string>
#include <vector>
#include <functional>
#include <chrono>
#include <variant>
#include <optional>

#include "locations.bison.h"

namespace fqparser {
using namespace std;
using namespace chrono;

// types for data in tokens passed from lexer to parser
struct NumberArg {
  uint64_t val;
  int sign = 0;
  bool operator==(const NumberArg&) const = default;
};

struct Test {
  optional<variant<string, NumberArg>> arg;
  function<bool()> val = []{ return false; };
};

struct RuleCallbacks {
  optional<function<void(void)>> binary_expression_from_and_cb{};
  optional<function<void(void)>> and_expression_from_list_cb{};
  optional<function<void(void)>> unary_expression_from_not_cb{};
  optional<function<void(const string&)>> string_arg_cb{};
};

// forward declare Lexer - cannot #include lexer header here because Lexer itself needs parser class definition that comes after this %code requires codeblock in generated header file
struct Lexer;

struct BisonParam {
  Lexer& lexer;
  RuleCallbacks ruleCb{};
  struct Stats {
    duration<double> parseTimeTakenSec;
    time_point<steady_clock> parseStartTime;
    time_point<steady_clock> parseEndTime;
  } stats{};
};

//OptionsMap curPositionalOptions = defaultPositionalOptions;

}
}

// namespace for parser generated by bison
%define api.namespace {fqparser}

// name of generated parser class
%define api.parser.class {FQParser}

// parser constructor parameter 1
// this is the yylex bison will call, it can have any signature we want since it's a lambda passed in by the client that wraps and hides the actual yylex call
%parse-param {function<FQParser::symbol_type(location&)> yylex}

// parser constructor parameter 2
%parse-param {BisonParam& bisonParam}

// parser constructor parameter 3
// only because each lex-param also must be parse-param
%parse-param {location& loc}

// yylex parameter 1
// pass location to lexer to update
%lex-param {location& loc}

// use c++ classes as semantic types
%define api.value.type variant

// use c++ objects, changes signature of yylex, yylex now returns PGNParser::symbol_type, yylex takes no parameters, change everywhere yylex is referenced, eg parse-param, any lambdas
%define api.token.constructor

// implicit move parameters in make_* token constructors
//%define api.value.automove

// enable c++ assert via internal YY_ASSERT to validate symbol use
%define parse.assert

%code provides {
// %code provides codeblock goes in .h after namespace and parser class
// everything here needs BnfParser defined earlier

// parser objects
namespace fqparser {

using namespace std;

}

}

%code top {
// % code top
// appears as topmost code block in generated .cpp file just below gnu license

using namespace std;
}

%{
// %{ unnamed codeblock goes at very top of .cpp file before namespace and parser class

#include <sstream>

%}

%code {
// %code
// appears in generated .cpp file after #include of generated .h file and before parser namespace and class

#include <string>
#include <chrono>

// Lexer header needed here because its methods are used in semantic actions
#include "lexer/fqparser_lexer.h"

using namespace std;

namespace {
  constexpr auto defaultInputName = "inputstream"s;
}

void fqparser::FQParser::error(const location& loc, const string& msg) {
  cerr << "error at " << loc << ": " << msg << "\n";
}

}

%initial-action {
// %initial-action codeblock goes inside parse() function in .cpp, it's a separate brace-scoped block, anything declared here is local to this block and cannot be used anywhere else in parse()

  bisonParam.stats.parseStartTime = steady_clock::now();

  if(loc.begin.filename == nullptr) {
    loc.initialize(&defaultInputName);
  }
}

// token definitions

// find command
%token                               FIND                     "find"

// find primaries

// tests
%token                               AMIN                     "-amin"
%token                               ANEWER                   "-anewer"
%token                               ATIME                    "-atime"
%token                               CMIN                     "-cmin"
%token                               CNEWER                   "-cnewer"
%token                               CTIME                    "-ctime"
%token                               EMPTY                    "-empty"
%token                               EXECUTABLE               "-executable"
%token                               FALSE                    "-false"
%token                               FSTYPE                   "-fstype"
%token                               GID                      "-gid"
%token                               GROUP                    "-group"
%token                               ILNAME                   "-ilname"
%token                               INAME                    "-iname"
%token                               INUM                     "-inum"
%token                               IPATH                    "-ipath"
%token                               IREGEX                   "-iregex"
%token                               IWHOLENAME               "-iwholename"
%token                               LINKS                    "-links"
%token                               LNAME                    "-lname"
%token                               MMIN                     "-mmin"
%token                               MTIME                    "-mtime"
%token                               NAME                     "-name"
%token                               NEWER                    "-newer"
%token                               NEWERXY                  "-newerXY"
%token                               NOGROUP                  "-nogroup"
%token                               NOUSER                   "-nouser"
%token                               PATH                     "-path"
%token                               PERM                     "-perm"
%token                               READABLE                 "-readable"
%token                               REGEX                    "-regex"
%token                               SAMEFILE                 "-samefile"
%token                               SIZE                     "-size"
%token                               TRUE                     "-true"
%token                               TYPE                     "-type"
%token                               UID                      "-uid"
%token                               USED                     "-used"
%token                               USER                     "-user"
%token                               WHOLENAME                "-wholename"
%token                               WRITABLE                 "-writable"
%token                               XTYPE                    "-xtype"

// actions
%token                               DELETE                   "-delete"
%token                               EXEC                     "-exec"
%token                               EXECDIR                  "-execdir"
%token                               FLS                      "-fls"
%token                               FPRINT                   "-fprint"
%token                               FPRINT0                  "-fprint0"
%token                               FPRINTF                  "-fprintf"
%token                               LS                       "-ls"
%token                               OK                       "-ok"
%token                               OKDIR                    "-okdir"
%token                               PRINT                    "-print"
%token                               PRINT0                   "-print0"
%token                               PRINTF                   "-printf"
%token                               PRUNE                    "-prune"
%token                               QUIT                     "-quit"

// global options
%token                               DEPTH                    "-depth"
%token                               FILES0_FROM              "-files0-from"
%token                               HELP                     "-help"
%token                               IGNORE_READDIR_RACE      "-ignore_readdir_race"
%token                               MAXDEPTH                 "-maxdepth"
%token                               MINDEPTH                 "-mindepth"
%token                               MOUNT                    "-mount"
%token                               NOIGNORE_READDIR_RACE    "-noignore_readdir_race"
%token                               NOLEAF                   "-noleaf"
%token                               XDEV                     "-xdev"

// positional options
%token                               DAYSTART                 "-daystart"
%token                               FOLLOW                   "-follow"
%token                               NOWARN                   "-nowarn"
%token                               REGEXTYPE                "-regextype"
%token                               WARN                     "-warn"

// operators
%token                               NOT                      "-not"
%token                               AND                      "-and"
%token                               OR                       "-or"
%token                               COMMA                    ","
%token                               LEFT_PAREN               "("
%token                               RIGHT_PAREN              ")"

%token                               SEMICOLON                ";"

// tokens with values
%token <NumberArg>                   NUMBER_ARG               "number"
%token <string>                      STRING_ARG               "string"
%token <string>                      STARTING_POINT


// the start or root symbol of grammar
%start fq

%%
// no code allowed in rules section outside of actions
// these are bison comments that do not appear in generated .cpp file

fq: find_commands

find_commands: find_command | find_commands find_command

find_command: "find" binary_expression | "find" starting_points binary_expression

starting_points: STARTING_POINT | starting_points STARTING_POINT

binary_expression: and_expression {
  if(bisonParam.ruleCb.binary_expression_from_and_cb) {
    (*bisonParam.ruleCb.binary_expression_from_and_cb)();
  }
}
| or_expression | comma_expression

and_expression:
  unary_expression
| and_expression and_operator unary_expression {
  if(bisonParam.ruleCb.and_expression_from_list_cb) {
    (*bisonParam.ruleCb.and_expression_from_list_cb)();
  }
}

and_operator: %empty | "-and"

or_expression: binary_expression "-or" and_expression

comma_expression: binary_expression "," and_expression

unary_expression: primary | "-not" primary  {
  if(bisonParam.ruleCb.unary_expression_from_not_cb) {
    (*bisonParam.ruleCb.unary_expression_from_not_cb)();
  }
}
| group

group: "(" binary_expression ")"

primary: test | action | global_option | positional_option

test:
  "-amin"                      number_arg
| "-anewer"                    string_arg
| "-atime"                     number_arg
| "-cmin"                      number_arg
| "-cnewer"                    string_arg
| "-ctime"                     number_arg
| "-empty"
| "-executable"
| "-false"
| "-fstype"                    string_arg
| "-gid"                       number_arg
| "-group"                     string_arg
| "-ilname"                    string_arg
| "-iname"                     string_arg
| "-inum"                      number_arg
| "-ipath"                     string_arg
| "-iregex"                    string_arg
| "-iwholename"                string_arg
| "-links"                     number_arg
| "-lname"                     string_arg
| "-mmin"                      number_arg
| "-mtime"                     number_arg
| "-name"                      string_arg
| "-newer"                     string_arg
| "-newerXY"                   string_arg
| "-nogroup"
| "-nouser"
| "-path"                      string_arg
| "-perm"                      string_arg
| "-readable"
| "-regex"                     string_arg
| "-samefile"
| "-size"                      number_arg
| "-true"
| "-type"                      string_arg
| "-uid"                       number_arg
| "-used"                      number_arg
| "-user"                      string_arg
| "-wholename"                 string_arg
| "-writable"
| "-xtype"                     string_arg

action:
  "-delete"
| "-exec"                      exec_args
| "-execdir"                   exec_args
| "-fls"                       string_arg
| "-fprint"                    string_arg
| "-fprint0"                   string_arg
| "-fprintf"                   string_arg
| "-ls"
| "-ok"                        exec_args
| "-okdir"                     exec_args
| "-print"
| "-print0"
| "-printf"                    string_arg
| "-prune"
| "-quit"

global_option:
  "-depth"
| "-files0-from"               string_arg
| "-help"
| "-ignore_readdir_race"
| "-maxdepth"                  number_arg
| "-mindepth"                  number_arg
| "-mount"
| "-noignore_readdir_race"
| "-noleaf"
| "-xdev"

positional_option:
  "-daystart"
| "-follow"
| "-nowarn"
| "-regextype"                 string_arg
| "-warn"

string_arg: set_lexer_string_state "string"[string] unset_lexer_state {
  if(bisonParam.ruleCb.string_arg_cb) {
    (*bisonParam.ruleCb.string_arg_cb)($string);
  }
}

number_arg: set_lexer_number_state "number" unset_lexer_state

exec_args: set_lexer_exec_state strings ";" unset_lexer_state

strings: "string" | strings "string"

// midrule actions

set_lexer_string_state: %empty {
  bisonParam.lexer.setState(Lexer::State::stringArg);
}

set_lexer_number_state: %empty {
  bisonParam.lexer.setState(Lexer::State::numberArg);
}

set_lexer_exec_state: %empty {
  bisonParam.lexer.setState(Lexer::State::execArgs);
}

unset_lexer_state: %empty {
  bisonParam.lexer.unsetState();
}

%%

// %code epilog block goes at bottom of generated .cpp file after namespace and parser implementation

#ifdef BUILD_BISON_MAIN

#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <getopt.h>

#include <string>
#include <iostream>
#include <optional>

#include "lexer/fqparser_lexer.h"
#include "fqparser.bison.h"

using namespace std;

using namespace fqparser;

void usage() {
  puts("Usage: fqparse [-h | --help] [--debug]");
  puts("It prints nothing if input is valid, otherwise it prints an error message with line numbers");
  puts("");
  puts("Options:");
  puts("--debug: turns on Bison parser and Flex lexer debug traces, off by default");
  puts("--stats: print timing stats on successful parse, off by default");
  puts("--help | -h: prints usage help");
}

int main(int argc, char* argv[])
{
  ios_base::sync_with_stdio(false);

  bool debug{};
  bool printStats{};

  auto inputFilename = "stdin"s;
  string changefile;

  option opts[] = {
    {"debug", no_argument, (int*)&debug, 1},
    {"stats", no_argument, (int*)&printStats, 1},
    {"help", no_argument, 0, 'h'},
    {0, 0, 0, 0}
  };

  for(int i, optLetter; (optLetter = getopt_long(argc, argv, "h", opts, &i)) != -1;) {
    switch(optLetter) {
    case 0:
      break;
    case 'h':
      usage();
      return 0;
    case '?':
      usage();
      return 1;
    default:
      break;
    }
  }

  Lexer lexer;

  location loc(&inputFilename);
  BisonParam bisonParam{lexer};

  FQParser parser([&lexer](location& loc) -> FQParser::symbol_type {
    return lexer.yylex(loc);
  },
  bisonParam,
  loc);

  lexer.set_debug(debug);
  parser.set_debug_level(debug);

  if(auto ev = parser(); ev != 0) {
    printf("parse failed\n");
    return ev;
  }

  if(auto ev = parser(); ev != 0) {
    fputs("parse failed\n", stderr);
    return ev;
  }

  if(printStats) {
    const auto& stats = bisonParam.stats;

    printf("parse_time %.9f sec\n", stats.parseTimeTakenSec.count());
  }

  return 0;
}

#endif
